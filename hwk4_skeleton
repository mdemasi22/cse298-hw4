%===============================================================
function hwk4_skeleton
%===============================================================
% Note that it is considered bad practice to use global variables when
% programming.  Don't do this at home!!!
global V_ROBOT OMEGA_MAX DT_ODOM WHEELBASE SIGMA_WHEEL SIGMA_BEARING;

% Initialize the robot parameters
V_ROBOT=5;          % Robot velocity in m/s
DT_ODOM = 0.1;      % Update rate for odometry (10 Hz)    
OMEGA_MAX=pi/4;     % Angular velocity bound in radians/s 
WHEELBASE = 1.0;    % Wheelbase of the robot in meters
SIGMA_WHEEL = 0.1;  % This is the std dev of the wheel velocity in m/s

% Camera measurement parameters
SIGMA_BEARING = 3*pi/180;   % Std dev for bearing estimates in radians

% Set up the figure 
close all; figure; axis equal; axis([0 120 0 80]); hold on;

% Initial robot pose
x0 = 15;  y0 = 15;  theta0 = 0;

% This is the actual robot position.  The robot is green.
robot = make_robot( x0, y0, theta0, 'size', 1.5, 'color', 'g', 'make_trail', 1 );
% This is the position of the robot as estimated by your EKF.  It is redd
robot_hat = make_robot( x0+5*randn, y0+5*randn, theta0+pi/8*randn, 'size', 1.5, 'color', 'r', 'make_trail', 1 );
% Make the path for the robot to follow
rectangle( 'position', [15 15 90 50],'linestyle',':', 'edgecolor', 'k' );

% This is our initial Covariance estimate.  Note is is NOT correct.  You
% can play with this as you see fit based upon other parameters given. 
P = [100 0 0; 0 100 0; 0 0 (pi/18)^2];

num_cameras = 0;
button = 1;
while 1    
    % Gets a single mouse input from the user.  The corresponding x-y
    % position will be the location of the camera
    [ x, y, button ] = ginput(1);
    % I changed this so you need to have at least 10 cameras before ending
    % the loop
    if button==3 && num_cameras >= 10, break; end
%     if button==1 && num_cameras >=10, break; end
    num_cameras = num_cameras+1;
    % This is the position of the camera, the range it is capable of 
    % transmitting and the color it is initially set to.  
    camera(num_cameras) = make_camera(robot,x, y, 20, [0.5 0.5 0.5],line);
end

for i=1:300
    if i <= 90
    distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    theta = 0.1*randn;
    theta2 = 0.3*randn;
    sign = randi([-1 0]);
    noise = 0.1*abs(randn)*sign;
    noise2 = 0.3*abs(randn)*sign;
    robot = move_robot( robot, robot.x+1, robot.y-noise+sin(theta), robot.theta);
    robot_hat = move_robot2( robot_hat, robot_hat.x+1, robot_hat.y-noise2+sin(theta2), robot_hat.theta+0.03*randn);
    pause(0.05);
    [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
    
    if distance > 2.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
    end
    elseif i > 90 && i <= 95
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    robot = move_robot( robot, robot.x, robot.y, robot.theta + (18*(pi/180)));
    robot_hat = move_robot2( robot_hat, robot_hat.x, robot_hat.y, robot_hat.theta+(18*(pi/180)) );
    pause(0.01);
    [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 2.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    elseif i > 95 && i <= 145
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    theta = 0.1*randn;
    theta2 = 0.3*randn;
    sign = randi([-1 0]);
    noise = 0.1*abs(randn)*sign;
    noise2 = 0.3*abs(randn)*sign;
    robot = move_robot(robot, robot.x-noise+sin(theta), robot.y+1, robot.theta);
    robot_hat = move_robot2( robot_hat, robot_hat.x-noise2+sin(theta2), robot_hat.y+1, robot_hat.theta+0.03*randn);
    pause(0.05);
     [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 2.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    elseif i > 145 && i <= 150
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    robot = move_robot(robot, robot.x, robot.y, robot.theta + (18*(pi/180)));
    robot_hat = move_robot2( robot_hat, robot_hat.x, robot_hat.y, robot_hat.theta+ (18*(pi/180)));
    pause(0.01);
    [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 1.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    elseif i > 150 && i <= 240
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    theta = 0.1*randn;
    theta2 = 0.3*randn;
    sign = randi([-1 0]);
    noise = 0.1*abs(randn)*sign;
    noise2 = 0.3*abs(randn)*sign;
    robot = move_robot(robot, robot.x-1, robot.y+noise+sin(theta), robot.theta);
    robot_hat = move_robot2( robot_hat, robot_hat.x-1, robot_hat.y+noise2+sin(theta2), robot_hat.theta+0.03*randn);
    pause(0.05);
     [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 1.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    elseif i > 240 && i <= 245
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    robot = move_robot(robot, robot.x, robot.y, robot.theta + (18*(pi/180)));
    robot_hat = move_robot2( robot_hat, robot_hat.x, robot_hat.y, robot_hat.theta+(18*(pi/180)));
    pause(0.01);
    [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 1.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    elseif i > 245 && i <= 295
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    theta = 0.1*randn;
    theta2 = 0.3*randn;
    sign = randi([-1 0]);
    noise = 0.1*abs(randn)*sign;
    noise2 = 0.3*abs(randn)*sign;
    robot = move_robot(robot, robot.x+noise+sin(theta), robot.y-1, robot.theta);
    robot_hat = move_robot2( robot_hat, robot_hat.x+noise2+sin(theta2), robot_hat.y-1, robot_hat.theta+0.03*randn);
    pause(0.05);
    [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 1.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    elseif i > 295 && i <= 300
        distance = sqrt((robot.x - robot_hat.x)^2 + (robot.y - robot_hat.y)^2);
    robot = move_robot(robot, robot.x, robot.y, robot.theta + (18*(pi/180)));
    robot_hat = move_robot2( robot_hat, robot_hat.x, robot_hat.y, robot_hat.theta+(18*(pi/180)));
    pause(0.01);
    [ camera(1), bearing ] = test_camera( camera(1), robot );
    [ camera(2), bearing ] = test_camera( camera(2), robot );
    [ camera(3), bearing ] = test_camera( camera(3), robot );
    [ camera(4), bearing ] = test_camera( camera(4), robot );
    [ camera(5), bearing ] = test_camera( camera(5), robot );
    [ camera(6), bearing ] = test_camera( camera(6), robot );
    [ camera(7), bearing ] = test_camera( camera(7), robot );
    [ camera(8), bearing ] = test_camera( camera(8), robot );
    [ camera(9), bearing ] = test_camera( camera(9), robot );
    [ camera(10), bearing ] = test_camera( camera(10), robot );
        if distance > 1.5
robot_hat = move_robot2( robot_hat, robot.x, robot.y, robot.theta);
        end
    end 
end

%Below is the rest of the hw5_skeleton and some ekf code that I tried to do
%but couldn't get it to work. Please look over it too, it's not much but
%the most I was able to do before doing what I did above.

%******************************************
% ADD OTHER CODE HERE
%******************************************
% current_leg=1;
% while current_leg~=9
%     % Measurement Update Phase
%     for i=1:num_cameras
%         % Each camera is tested to see if it can be seen by the robot.  
%         % Visible cameras are set to green, and a line reflecting its
%         % measured position as estimated by the robot is also plotted.  
%         [ camera(i), bearing ] = test_camera( camera(i), robot );        
%         if ~isempty( bearing )
%             [ robot_hat, P ] = MeasurementUpdate( robot_hat, P, camera(i), bearing );
% 
% %******************************************
% % ADD OTHER CODE HERE
% %******************************************
% 
%         end
%     end
% 
%     % Time Update Phase.  Note we do multiple time updates for each
%     % measurement update because the update rate of the odometry is higher
%     for j=1:1/DT_ODOM
%         [ robot, robot_hat, P ] = TimeUpdate( robot, robot_hat, P, legV, legOmega );        
% %******************************************
% % ADD OTHER CODE HERE
% %******************************************
%     end
% 
% end

%==================================================================================
% function [ robot, robot_hat, P ] = TimeUpdate( robot, robot_hat, P, v, omega )
% %==================================================================================
% global DT_ODOM WHEELBASE SIGMA_WHEEL;
% %******************************************
% % ADD OTHER CODE HERE
% %******************************************
% 
% 
% %==================================================================================
% function [ robotHat, P ] = MeasurementUpdate( robot_hat, P, camera, range )
% %==================================================================================
% global SIGMA_BEARING;
% %******************************************
% % ADD OTHER CODE HERE
% %******************************************
% estimate_bearing = atan2(robot_hat.y - camera.y, robot_hat.x - camera.x) - robot_hat.theta;
% zhat = pi_to_pi(range - estimate_bearing);
% Ht = ((robot_hat.y - camera.y)/((robot_hat.x - camera.x)^2 + (robot_hat.y - camera.y)^2));
% Q = 0;
% I = [1 0 0
%      0 1 0
%      0 0 1];
% St = (Ht*P*Ht'-Q);
% Kt = P*Ht'*St^-1;
% X = robot_hat.x + Kt(1)*zhat;
% Y = robot_hat.y + Kt(2)*zhat;
% new_theta = (robot_hat.theta + pi_to_pi(Kt(3)*zhat));
% robotHat = move_robot(robot_hat, X, Y, new_theta);
% p = (I - Kt*Ht)*P;
